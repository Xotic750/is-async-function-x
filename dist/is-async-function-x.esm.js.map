{"version":3,"sources":["../src/is-async-function-x.js"],"names":[],"mappings":"AAAA,OAAO,WAAP,MAAwB,iBAAxB;AACA,OAAO,cAAP,MAA2B,qBAA3B;AACA,OAAO,SAAP,MAAsB,mBAAtB;AACA,OAAO,eAAP,MAA4B,oBAA5B;AACA,OAAO,eAAP,MAA4B,oBAA5B;AACA,OAAO,OAAP,MAAoB,WAApB;AACA,OAAO,SAAP,MAAsB,oBAAtB;AAEA,IAAM,SAAS,GAAG,iBAAlB;AACA,IAAM,cAAc,GAAG,SAAS,CAAC,SAAS,CAAC,IAAX,CAAhC;AACA,IAAM,WAAW,GAAG,OAAO,CAAC,WAA5B;AACA,IAAM,SAAS,GAAG,WAAW,CAAC,QAA9B;AACA,IAAM,OAAO,GAAG,OAAO,CAAC,SAAS,SAAT,GAAqB;AAC3C,SAAO,eAAe,CAAC,WAAW,CAAC,4BAAD,CAAX,EAAD,CAAtB;AACD,CAFsB,CAAvB;AAIA,IAAM,aAAa,GAAG,OAAO,CAAC,KAAR,KAAkB,KAAxC;AACA,IAAM,UAAU,GAAG,OAAO,CAAC,KAA3B;;AAEA,IAAM,eAAe,GAAG,SAAS,eAAT,CAAyB,EAAzB,EAA6B;AACnD,SAAO,OAAO,CAAC,SAAS,SAAT,GAAqB;AAClC,WAAO,SAAS,CAAC,eAAe,CAAC,SAAS,CAAC,IAAV,CAAe,EAAf,CAAD,EAAqB,GAArB,CAAhB,CAAhB;AACD,GAFa,CAAd;AAGD,CAJD;;AAMA,IAAM,OAAO,GAAG,SAAS,OAAT,CAAiB,EAAjB,EAAqB;AACnC,SAAO,cAAc,GAAG,eAAe,CAAC,EAAD,CAAf,KAAwB,UAA3B,GAAwC,WAAW,CAAC,EAAD,CAAX,KAAoB,wBAAjF;AACD,CAFD;AAIA;;;;;;;;;AAOA,IAAM,eAAe,GAAG,SAAS,eAAT,CAAyB,EAAzB,EAA6B;AACnD,MAAI,aAAa,KAAK,KAAlB,IAA2B,OAAO,EAAP,KAAc,UAA7C,EAAyD;AACvD,WAAO,KAAP;AACD;;AAED,MAAM,MAAM,GAAG,eAAe,CAAC,EAAD,CAA9B;;AAEA,MAAI,MAAM,CAAC,KAAX,EAAkB;AAChB,WAAO,KAAP;AACD;;AAED,MAAI,cAAc,CAAC,SAAD,EAAY,MAAM,CAAC,KAAnB,CAAlB,EAA6C;AAC3C,WAAO,IAAP;AACD;;AAED,SAAO,OAAO,CAAC,EAAD,CAAd;AACD,CAhBD;;AAkBA,eAAe,eAAf","file":"is-async-function-x.esm.js","sourcesContent":["import toStringTag from 'to-string-tag-x';\nimport hasToStringTag from 'has-to-string-tag-x';\nimport normalise from 'normalize-space-x';\nimport replaceComments from 'replace-comments-x';\nimport $getPrototypeOf from 'get-prototype-of-x';\nimport attempt from 'attempt-x';\nimport methodize from 'simple-methodize-x';\n\nconst isFnRegex = /^async function/;\nconst methodizedTest = methodize(isFnRegex.test);\nconst functionCtr = attempt.constructor;\nconst fToString = functionCtr.toString;\nconst testRes = attempt(function attemptee() {\n  return $getPrototypeOf(functionCtr('return async function() {}')());\n});\n\nconst supportsAsync = testRes.threw === false;\nconst asyncProto = testRes.value;\n\nconst attemptToString = function attemptToString(fn) {\n  return attempt(function attemptee() {\n    return normalise(replaceComments(fToString.call(fn), ' '));\n  });\n};\n\nconst compare = function compare(fn) {\n  return hasToStringTag ? $getPrototypeOf(fn) === asyncProto : toStringTag(fn) === '[object AsyncFunction]';\n};\n\n/**\n * Checks if `value` is classified as an `Async Function` object.\n *\n * @param {*} fn - The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified,\n * else `false`.\n */\nconst isAsyncFunction = function isAsyncFunction(fn) {\n  if (supportsAsync === false || typeof fn !== 'function') {\n    return false;\n  }\n\n  const result = attemptToString(fn);\n\n  if (result.threw) {\n    return false;\n  }\n\n  if (methodizedTest(isFnRegex, result.value)) {\n    return true;\n  }\n\n  return compare(fn);\n};\n\nexport default isAsyncFunction;\n"]}